from brownie import (
    network,
    accounts,
    config,
)

FORKED_LOCAL_ENVIRONMENTS = ["mainnet-fork", "mainnet-fork-dev"]
LOCAL_BLOCKCHAIN_ENVIRONMENTS = [
    "development",
    "ganache",
    "ganache-local",
    "mainnet-fork",
]


def get_account(index=None, account_id=None):
    if index is not None:
        return accounts[index]
    if account_id is not None:
        return accounts.load(id)
    active_network: str = network.show_active()
    if (
        active_network in LOCAL_BLOCKCHAIN_ENVIRONMENTS
        or active_network in FORKED_LOCAL_ENVIRONMENTS
    ):
        # use one of the accounts automatically generated by brownie
        return accounts[0]
    return accounts.add(config["wallets"]["from_key"])


def encode_function_data(intializer=None, *args):
    args = args if len(args) else b""

    if intializer:
        return intializer.encode_input(*args)
    return b""


def upgrade(
    account,
    proxy,
    new_implementation_addr,
    proxy_admin_contract=None,
    initializer=None,
    *args
):
    encoded_function_call = (
        encode_function_data(initializer, *args) if initializer else None
    )
    if proxy_admin_contract:
        if encoded_function_call:
            transaction = proxy_admin_contract.upgradeAndCall(
                proxy.address,
                new_implementation_addr,
                encoded_function_call,
                {"from": account},
            )
        else:
            transaction = proxy_admin_contract.upgrade(
                proxy.address,
                new_implementation_addr,
                {"from": account},
            )
    else:
        # no proxy admin contract, which means we will call the proxy direclty from our account
        if encoded_function_call:
            transaction = proxy.upgradeToAndCall(
                new_implementation_addr, encoded_function_call, {"from": account}
            )
        else:
            transaction = proxy.upgradeTo(new_implementation_addr, {"from": account})
    return transaction
